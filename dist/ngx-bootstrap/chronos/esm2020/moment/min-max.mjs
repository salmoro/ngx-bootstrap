// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
import { isArray, isDateValid } from '../utils/type-checks';
import { isAfter, isBefore } from '../utils/date-compare';
function pickBy(fn, dates) {
    let _dates;
    const _firstArg = dates[0];
    if (isArray(_firstArg) && dates.length === 1) {
        _dates = _firstArg;
    }
    else if (isArray(dates)) {
        _dates = dates;
    }
    if (!_dates || !_dates.length) {
        return new Date();
    }
    let res = _dates[0];
    for (let i = 1; i < _dates.length; ++i) {
        // if (!moments[i].isValid() || moments[i][fn](res)) {
        if (!isDateValid(_dates[i]) || fn.call(null, _dates[i], res)) {
            res = _dates[i];
        }
    }
    return res;
}
// TODO: Use [].sort instead?
export function min(...args) {
    // const args = [].slice.call(arguments, 0);
    return pickBy(isBefore, args);
}
export function max(...args) {
    // const args = [].slice.call(arguments, 0);
    return pickBy(isAfter, args);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWluLW1heC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jaHJvbm9zL21vbWVudC9taW4tbWF4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9FQUFvRTtBQUNwRSwwREFBMEQ7QUFDMUQsRUFBRTtBQUNGLHlFQUF5RTtBQUN6RSwrQ0FBK0M7QUFDL0MsT0FBTyxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBRzFELFNBQVMsTUFBTSxDQUFDLEVBQTBELEVBQUUsS0FBd0I7SUFDbEcsSUFBSSxNQUFjLENBQUM7SUFDbkIsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLElBQUksT0FBTyxDQUFPLFNBQVMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ2xELE1BQU0sR0FBRyxTQUFTLENBQUM7S0FDcEI7U0FBTSxJQUFJLE9BQU8sQ0FBTyxLQUFLLENBQUMsRUFBRTtRQUMvQixNQUFNLEdBQUcsS0FBSyxDQUFDO0tBQ2hCO0lBRUQsSUFBSSxDQUFDLE1BQU0sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7UUFDN0IsT0FBTyxJQUFJLElBQUksRUFBRSxDQUFDO0tBQ25CO0lBQ0QsSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1FBQ3RDLHNEQUFzRDtRQUN0RCxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsRUFBRTtZQUM1RCxHQUFHLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pCO0tBQ0Y7SUFFRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFFRCw2QkFBNkI7QUFDN0IsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLElBQVk7SUFDakMsNENBQTRDO0lBRTVDLE9BQU8sTUFBTSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBRUQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFHLElBQVk7SUFDakMsNENBQTRDO0lBRTVDLE9BQU8sTUFBTSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztBQUMvQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcclxuLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxyXG4vL1xyXG4vLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXHJcbi8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXHJcbmltcG9ydCB7IGlzQXJyYXksIGlzRGF0ZVZhbGlkIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVja3MnO1xyXG5pbXBvcnQgeyBpc0FmdGVyLCBpc0JlZm9yZSB9IGZyb20gJy4uL3V0aWxzL2RhdGUtY29tcGFyZSc7XHJcbmltcG9ydCB7IFVuaXRPZlRpbWUgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5mdW5jdGlvbiBwaWNrQnkoZm46IChkYXRlOiBEYXRlLCBkYXRlMjogRGF0ZSwgdW5pdDogVW5pdE9mVGltZSkgPT4gYm9vbGVhbiwgZGF0ZXM6IERhdGVbXSB8IERhdGVbXVtdKTogRGF0ZSB7XHJcbiAgbGV0IF9kYXRlczogRGF0ZVtdO1xyXG4gIGNvbnN0IF9maXJzdEFyZyA9IGRhdGVzWzBdO1xyXG4gIGlmIChpc0FycmF5PERhdGU+KF9maXJzdEFyZykgJiYgZGF0ZXMubGVuZ3RoID09PSAxKSB7XHJcbiAgICBfZGF0ZXMgPSBfZmlyc3RBcmc7XHJcbiAgfSBlbHNlIGlmIChpc0FycmF5PERhdGU+KGRhdGVzKSkge1xyXG4gICAgX2RhdGVzID0gZGF0ZXM7XHJcbiAgfVxyXG5cclxuICBpZiAoIV9kYXRlcyB8fCAhX2RhdGVzLmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKCk7XHJcbiAgfVxyXG4gIGxldCByZXMgPSBfZGF0ZXNbMF07XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBfZGF0ZXMubGVuZ3RoOyArK2kpIHtcclxuICAgIC8vIGlmICghbW9tZW50c1tpXS5pc1ZhbGlkKCkgfHwgbW9tZW50c1tpXVtmbl0ocmVzKSkge1xyXG4gICAgaWYgKCFpc0RhdGVWYWxpZChfZGF0ZXNbaV0pIHx8IGZuLmNhbGwobnVsbCwgX2RhdGVzW2ldLCByZXMpKSB7XHJcbiAgICAgIHJlcyA9IF9kYXRlc1tpXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiByZXM7XHJcbn1cclxuXHJcbi8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XHJcbmV4cG9ydCBmdW5jdGlvbiBtaW4oLi4uYXJnczogRGF0ZVtdKTogRGF0ZSB7XHJcbiAgLy8gY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuXHJcbiAgcmV0dXJuIHBpY2tCeShpc0JlZm9yZSwgYXJncyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXgoLi4uYXJnczogRGF0ZVtdKTogRGF0ZSB7XHJcbiAgLy8gY29uc3QgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuXHJcbiAgcmV0dXJuIHBpY2tCeShpc0FmdGVyLCBhcmdzKTtcclxufVxyXG4iXX0=